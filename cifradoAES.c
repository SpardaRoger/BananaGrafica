/* Universidad Nacional Autónoma de México */
/* Paulo Contreras Flores */
/* paulo.contreras.flores@gmail.com */

/*Modificaciones por:
    Banda Martinez Cesar Eduardo
    Limon Hernandez Raul Rogelio
 */

#include <stdio.h>
#include <stdlib.h>
#include "aes.h"

B16 FF(B16, B8);

main(){

    int i,j;

    B8 key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
                  0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};

    B8 in[4][4] = {{0x32,0x88,0x31,0xe0},
                   {0x43,0x5a,0x31,0x37},
                   {0xf6,0x30,0x98,0x07},
                   {0xa8,0x8d,0xa2,0x34}};
    B8 out[4][4];
    B16 keylength = 128;

    printf("\n\n\t\t\t  PLAINTEXT: ");
    for(i=0;i<4;i++)
        for(j=0;j<4;j++)
            printf(" %x ",in[j][i]);


    printf("\n\n\t\t\t\tKEY: ");
    for(i=0;i<16;i++)
    	printf(" %x ",key[i]);
   	i++;


    KeyBlockRound(keylength);


    B32 w[Nb*(Nr+1)];

    KeyExpansion(key, w, Nk);

    cipherAES(in,out,w);


}

void cipherAES(B8 in[4][4], B8 out[4][4], B32 w[Nb*(Nr+1)]){

    int ronda = 0,i,j;

    printf("\n\n\t\t\tRound[%i].input\t",ronda);

	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

    printf("\n\n\t\t\tRound[%i].k_sch\t",ronda);
        for(i=0;i<4;i++)
            printf("%x",w[i]);

    AddRoundKey(in,w,ronda);

    for(ronda=1;ronda<Nr;ronda++){

	printf("\n\n\t\t\tRound[%i].start\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

        SubBytes(in);

	printf("\n\n\t\t\tRound[%i].s_box\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

        ShiftRows(in);

	printf("\n\n\t\t\tRound[%i].s_row\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

        MixColumns(in);

	printf("\n\n\t\t\tRound[%i].m_col\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

        AddRoundKey(in,w,ronda);

        printf("\n\n\t\t\tRound[%i].k_sch\t",ronda);

        for(i=0;i<4;i++)
            printf("%x",w[4*ronda+i]);

    }

    ronda=Nr;

    SubBytes(in);

    printf("\n\n\t\t\tRound[%i].s_box\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}




    ShiftRows(in);


    printf("\n\n\t\t\tRound[%i].s_row\t",ronda);
	for(i=0;i<4;i++)
	    for(j=0;j<4;j++)
		{
		  printf("%x",in[j][i]);
		}

    AddRoundKey(in,w,ronda);

    printf("\n\n\t\t\tRound[%i].k_sch\t",ronda);

        for(i=0;i<4;i++)
            printf("%x",w[ronda+i]);

    printf("\n\n\t\t\t\tOUT: ");

    for(i=0;i<4;i++)
        for(j=0;j<4;j++)
            out[i][j]=in[i][j];

     printf("");
   for(j=0;j<4;j++)
        for(i=0;i<4;i++){
            printf(" %x ",out[i][j]);
            if(i==3)
                printf("");
        }
   printf("\n\n");

}


void MixColumns(B8 in[4][4]){

  int i=0,j;

  B8 coef2=0x02;
  B8 coef3=0x03;

  B16 temp[4][4];

  for(i=0;i<4;i++)
    for(j=0;j<4;j++)
        temp[i][j]=in[i][j];

    for(i=0;i<4;i++){
      in[0][i]=FF(temp[0][i],coef2)^FF(temp[1][i],coef3)^temp[2][i]^temp[3][i];
      in[1][i]=temp[0][i]^FF(temp[1][i],coef2)^FF(temp[2][i],coef3)^temp[3][i];
      in[2][i]=temp[0][i]^temp[1][i]^FF(temp[2][i],coef2)^FF(temp[3][i],coef3);
      in[3][i]=temp[1][i]^temp[2][i]^FF(temp[3][i],coef2)^FF(temp[0][i],coef3);
    }

}

B16 FF(B16 celda, B8 coef){

  B8 L[16][16]={{0x00,0x00,0x19,0x01,0x32,0x02,0x1a,0xc6,0x4b,0xc7,0x1b,0x68,0x33,0xee,0xdf,0x03},
               {0x64,0x04,0xe0,0x0e,0x34,0x8d,0x81,0xef,0x4c,0x71,0x08,0xc8,0xf8,0x69,0x1c,0xc1},
               {0x7d,0xc2,0x1d,0xb5,0xf9,0xb9,0x27,0x6a,0x4d,0xe4,0xa6,0x72,0x9a,0xc9,0x09,0x78},
               {0x65,0x2f,0x8a,0x05,0x21,0x0f,0xe1,0x24,0x12,0xf0,0x82,0x45,0x35,0x93,0xda,0x8e},
               {0x96,0x8f,0xdb,0xbd,0x36,0xd0,0xce,0x94,0x13,0x5c,0xd2,0xf1,0x40,0x46,0x83,0x38},
               {0x66,0xdd,0xfd,0x30,0xbf,0x06,0x8b,0x62,0xb3,0x25,0xe2,0x98,0x22,0x88,0x91,0x10},
               {0x7e,0x6e,0x48,0xc3,0xa3,0xb6,0x1e,0x42,0x3a,0x6b,0x28,0x54,0xfa,0x85,0x3d,0xba},
               {0x2b,0x79,0x0a,0x15,0x9b,0x9f,0x5e,0xca,0x4e,0xd4,0xac,0xe5,0xf3,0x73,0xa7,0x57},
               {0xaf,0x58,0xa8,0x50,0xf4,0xea,0xd6,0x74,0x4f,0xae,0xe9,0xd5,0xe7,0xe6,0xad,0xe8},
               {0x2c,0xd7,0x75,0x7a,0xeb,0x16,0x0b,0xf5,0x59,0xcb,0x5f,0xb0,0x9c,0xa9,0x51,0xa0},
               {0x7f,0x0c,0xf6,0x6f,0x17,0xc4,0x49,0xec,0xd8,0x43,0x1f,0x2d,0xa4,0x76,0x7b,0xb7},
               {0xcc,0xbb,0x3e,0x5a,0xfb,0x60,0xb1,0x86,0x3b,0x52,0xa1,0x6c,0xaa,0x55,0x29,0x9d},
               {0x97,0xb2,0x87,0x90,0x61,0xbe,0xdc,0xfc,0xbc,0x95,0xcf,0xcd,0x37,0x3f,0x5b,0xd1},
               {0x53,0x39,0x84,0x3c,0x41,0xa2,0x6d,0x47,0x14,0x2a,0x9e,0x5d,0x56,0xf2,0xd3,0xab},
               {0x44,0x11,0x92,0xd9,0x23,0x20,0x2e,0x89,0xb4,0x7c,0xb8,0x26,0x77,0x99,0xe3,0xa5},
               {0x67,0x4a,0xed,0xde,0xc5,0x31,0xfe,0x18,0x0d,0x63,0x8c,0x80,0xc0,0xf7,0x70,0x07},
              };

  B8 E[16][16]={{0x01,0x03,0x05,0x0f,0x11,0x33,0x55,0xff,0x1a,0x2e,0x72,0x96,0xa1,0xf8,0x13,0x35},
                {0x5f,0xe1,0x38,0x48,0xd8,0x73,0x95,0xa4,0xf7,0x02,0x06,0x0a,0x1e,0x22,0x66,0xaa},
                {0xe5,0x34,0x5c,0xe4,0x37,0x59,0xeb,0x26,0x6a,0xbe,0xd9,0x70,0x90,0xab,0xe6,0x31},
                {0x53,0xf5,0x04,0x0c,0x14,0x3c,0x44,0xcc,0x4f,0xd1,0x68,0xb8,0xd3,0x6e,0xb2,0xcd},
                {0x4c,0xd4,0x67,0xa9,0xe0,0x3b,0x4d,0xd7,0x62,0xa6,0xf1,0x08,0x18,0x28,0x78,0x88},
                {0x83,0x9e,0xb9,0xd0,0x6b,0xbd,0xdc,0x7f,0x81,0x98,0xb3,0xce,0x49,0xdb,0x76,0x9a},
                {0xb5,0xc4,0x57,0xf9,0x10,0x30,0x50,0xf0,0x0b,0x1d,0x27,0x69,0xbb,0xd6,0x61,0xa3},
                {0xfe,0x19,0x2b,0x7d,0x87,0x92,0xad,0xec,0x2f,0x71,0x93,0xae,0xe9,0x20,0x60,0xa0},
                {0xfb,0x16,0x3a,0x4e,0xd2,0x6d,0xb7,0xc2,0x5d,0xe7,0x32,0x56,0xfa,0x15,0x3f,0x41},
                {0xc3,0x5e,0xe2,0x3d,0x47,0xc9,0x40,0xc0,0x5b,0xed,0x2c,0x74,0x9c,0xbf,0xda,0x75},
                {0x9f,0xba,0xd5,0x64,0xac,0xef,0x2a,0x7e,0x82,0x9d,0xbc,0xdf,0x7a,0x8e,0x89,0x80},
                {0x9b,0xb6,0xc1,0x58,0xe8,0x23,0x65,0xaf,0xea,0x25,0x6f,0xb1,0xc8,0x43,0xc5,0x54},
                {0xfc,0x1f,0x21,0x63,0xa5,0xf4,0x07,0x09,0x1b,0x2d,0x77,0x99,0xb0,0xcb,0x46,0xca},
                {0x45,0xcf,0x4a,0xde,0x79,0x8b,0x86,0x91,0xa8,0xe3,0x3e,0x42,0xc6,0x51,0xf3,0x0e},
                {0x12,0x36,0x5a,0xee,0x29,0x7b,0x8d,0x8c,0x8f,0x8a,0x85,0x94,0xa7,0xf2,0x0d,0x17},
                {0x39,0x4b,0xdd,0x7c,0x84,0x97,0xa2,0xfd,0x1c,0x24,0x6c,0xb4,0xc7,0x52,0xf6,0x01},
              };

    if(coef==0x02)
        celda=0x19+L[celda>>4][celda&(0x0f)];

    if(coef==0x03)
        celda=0x01+L[celda>>4][celda&(0x0f)];

   // printf("%x\n",L[celda>>4][celda&(0x0f)]);

    if(celda > 0xff)
        celda=celda-0xff;

    celda=E[celda>>4][celda&(0x0f)];

    return celda;

}

void ShiftRows(B8 in[4][4]){

    int i,v;
    B8 vector[4];

    for(i=1;i<4;i++){

        if(i==1){

            for(v=0;v<4;v++)
                vector[v]=in[i][v];

            in[i][0]=vector[1];
            in[i][1]=vector[2];
            in[i][2]=vector[3];
            in[i][3]=vector[0];

        }

        if(i==2){

            for(v=0;v<4;v++)
                vector[v]=in[i][v];

            in[i][0]=vector[2];
            in[i][1]=vector[3];
            in[i][2]=vector[0];
            in[i][3]=vector[1];

        }

        if(i==3){

            for(v=0;v<4;v++)
                vector[v]=in[i][v];

            in[i][0]=vector[3];
            in[i][1]=vector[0];
            in[i][2]=vector[1];
            in[i][3]=vector[2];

        }

    }

}

void SubBytes(B8 in[4][4]){

    B8 X_BOX[16][16]={{0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76},
                      {0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0},
                      {0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15},
                      {0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75},
                      {0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84},
                      {0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf},
                      {0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8},
                      {0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2},
                      {0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73},
                      {0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb},
                      {0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79},
                      {0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08},
                      {0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a},
                      {0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e},
                      {0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf},
                      {0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16}
                       };

    B32 arr;
    int i;

    int coord[8];

    for(i=0;i<4;i++){
        if(i==0){
            in[i][0]=X_BOX[in[i][0]>>4][in[i][0] & (0x0f)];
            in[i][1]=X_BOX[in[i][1]>>4][in[i][1] & (0x0f)];
            in[i][2]=X_BOX[in[i][2]>>4][in[i][2] & (0x0f)];
            in[i][3]=X_BOX[in[i][3]>>4][in[i][3] & (0x0f)];
        }

        if(i==1){
            in[i][0]=X_BOX[in[i][0]>>4][in[i][0] & (0x0f)];
            in[i][1]=X_BOX[in[i][1]>>4][in[i][1] & (0x0f)];
            in[i][2]=X_BOX[in[i][2]>>4][in[i][2] & (0x0f)];
            in[i][3]=X_BOX[in[i][3]>>4][in[i][3] & (0x0f)];
        }

        if(i==2){
            in[i][0]=X_BOX[in[i][0]>>4][in[i][0] & (0x0f)];
            in[i][1]=X_BOX[in[i][1]>>4][in[i][1] & (0x0f)];
            in[i][2]=X_BOX[in[i][2]>>4][in[i][2] & (0x0f)];
            in[i][3]=X_BOX[in[i][3]>>4][in[i][3] & (0x0f)];
        }

        if(i==3){
            in[i][0]=X_BOX[in[i][0]>>4][in[i][0] & (0x0f)];
            in[i][1]=X_BOX[in[i][1]>>4][in[i][1] & (0x0f)];
            in[i][2]=X_BOX[in[i][2]>>4][in[i][2] & (0x0f)];
            in[i][3]=X_BOX[in[i][3]>>4][in[i][3] & (0x0f)];
        }

    }




}

void AddRoundKey(B8 in[4][4], B32 w[Nb*(Nr+1)], int ronda){

    int i;

    for(i=0;i<4;i++){
        if(i==0){
            in[0][i]=(w[4*ronda]>>24) ^ in[0][i];
            in[1][i]=((w[4*ronda]>>16) & (0x00ff)) ^ in[1][i];
            in[2][i]=((w[4*ronda]>>8) & (0x0000ff)) ^ in[2][i];
            in[3][i]=(w[4*ronda] & (0x000000ff)) ^ in[3][i];

        }

        if(i==1){
            in[0][i]=(w[4*ronda+1]>>24) ^ in[0][i];
            in[1][i]=((w[4*ronda+1]>>16) & (0x00ff)) ^ in[1][i];
            in[2][i]=((w[4*ronda+1]>>8) & (0x0000ff)) ^ in[2][i];
            in[3][i]=(w[4*ronda+1] & (0x000000ff)) ^ in[3][i];

        }

        if(i==2){
            in[0][i]=(w[4*ronda+2]>>24) ^ in[0][i];
            in[1][i]=((w[4*ronda+2]>>16) & (0x00ff)) ^ in[1][i];
            in[2][i]=((w[4*ronda+2]>>8) & (0x0000ff)) ^ in[2][i];
            in[3][i]=(w[4*ronda+2] & (0x000000ff)) ^ in[3][i];

        }

        if(i==3){
            in[0][i]=(w[4*ronda+3]>>24) ^ in[0][i];
            in[1][i]=((w[4*ronda+3]>>16) & (0x00ff)) ^ in[1][i];
            in[2][i]=((w[4*ronda+3]>>8) & (0x0000ff)) ^ in[2][i];
            in[3][i]=(w[4*ronda+3] & (0x000000ff)) ^ in[3][i];

        }


    }

}

void KeyExpansion(B8 key[4*Nk], B32 w[Nb*(Nr+1)], B16 Nk){

    B32 temp;
    B16 i = 0;
    int ronda = 1;
    int No_key=1;


   while(i < Nk){
       w[i] = ((key[4*i]) << 24) | ((key[4*i+1]) << 16) |
               ((key[4*i+2]) << 8) | ((key[4*i+3]));
       i = i + 1;
   }

   i=Nk;

   // printf("No. i |  temp   |  After RotWord   |  After SubWord   |  Rcon   | After XOR with Rcon |  w[i-Nk]   |   Sub-Keys\n");

   while(i < Nb*(Nr+1)){

     // printf("\n%d\t",i);



      temp=w[i-1];



      //printf("%x\t",temp);

     // if(i==4)
       //     printf("\t");

      if(i%Nk==0){
        SubWord(RotWord(&temp));
         //if(i==20|i==28)
        //    printf("\t");
       // printf("\t%x",temp);
        temp=temp^(RotCon(ronda));

        //printf("\t%x",RotCon(ronda));
       // if(i==4|i==8|i==12|i==16)
            //printf("\t");
       // printf("\t");
       // printf("%x",temp);

        ronda++;

      }else if((Nk > 6) && (i%Nk==4))
          temp=SubWord(&temp);

    // if(i%Nk==0)
      //  printf("\t%x",w[i-Nk]);
    // else
       // printf("\t\t\t\t\t\t\t\t%x",w[i-Nk]);


      w[i]=w[i-Nk]^temp;

      ///if(i%Nk==0)
       // printf("\t%x",w[i]);
//     else if(i==7)
      //  printf("\t\t%x",w[i]);
     //else
      //  printf("\t%x",w[i]);
      i++;
   }



  /*
   printf("\n\nLLAVE:\n\n");

   for(i=0;i<4;i++)
        printf("\n%x",w[i]);

   for(i=4;i < Nb*(Nr+1);i++){

        if(i%Nk==0){
            printf("\n\nSub-llave %d\n",No_key);
            No_key++;
        }

        printf("%x\n",w[i]);

   }*/

}

int RotCon(int factor){

    if(factor==1)
        return 0x01000000;

    if(factor==2)
        return 0x02000000;

    if(factor==3)
        return 0x04000000;

    if(factor==4)
        return 0x08000000;

    if(factor==5)
        return 0x10000000;

    if(factor==6)
        return 0x20000000;

    if(factor==7)
        return 0x40000000;

    if(factor==8)
        return 0x80000000;

    if(factor==9)
        return 0x1b000000;

    if(factor==10)
        return 0x36000000;
}

int RotWord(B32 *temp){

    *temp = (*temp << 8)|(*temp >> 24);

    //printf("%x",*temp);

    return temp;

}



void KeyBlockRound(B16 keylength){

    switch(keylength){
        case 128: Nk = 4; Nr = 10; break;
        case 192: Nk = 6; Nr = 12; break;
        case 256: Nk = 8; Nr = 14; break;
        default: printf("Error-longitud de llave incorrecto\n");
    }

}


void SubWord(B32 *temp){

    B8 X_BOX[16][16]={{0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76},
                      {0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0},
                      {0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15},
                      {0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75},
                      {0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84},
                      {0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf},
                      {0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8},
                      {0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2},
                      {0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73},
                      {0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb},
                      {0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79},
                      {0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08},
                      {0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a},
                      {0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e},
                      {0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf},
                      {0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16}
                       };

    B32 arr;
    int i;

    int coord[8];


    for(i=0;i<8;i++){
        if(i==0){
            coord[i]=*temp >> 28;
            coord[i+1]=(*temp >> 24)&(0x0f);
        }

        if(i==2){
            coord[i]=(*temp >> 20)&(0x00f);
            coord[i+1]=(*temp >> 16)&(0x000f);
        }

        if(i==4){
            coord[i]=(*temp >> 12)&(0x0000f);
            coord[i+1]=(*temp >> 8)&(0x00000f);
        }

        if(i==6){
            coord[i]=(*temp >> 4)&(0x000000f);
            coord[i+1]=*temp&(0x0000000f);
        }

    }


    arr=(X_BOX[coord[0]][coord[1]] << 24)|(X_BOX[coord[2]][coord[3]] << 16)|(X_BOX[coord[4]][coord[5]] << 8)|(X_BOX[coord[6]][coord[7]]);

    *temp=arr;


}
